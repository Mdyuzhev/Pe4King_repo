package com.pe4king.renderers.postman

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.SerializationFeature
import com.pe4king.core.models.*
import com.pe4king.renderers.TestRenderer

/**
 * Renders TestModel to Postman Collection v2.1 format.
 */
class PostmanRenderer : TestRenderer {

    override val name: String = "postman"
    override val fileExtension: String = ".json"

    private val scripts = PostmanScriptGenerator()
    private val objectMapper = ObjectMapper().apply {
        enable(SerializationFeature.INDENT_OUTPUT)
    }

    override fun render(model: TestModel): List<GeneratedFile> {
        val collection = buildCollection(model)
        val filename = model.meta.specTitle
            .lowercase()
            .replace(Regex("[^a-z0-9]+"), "_")
            .take(50)

        return listOf(
            GeneratedFile(
                filename = "${filename}_postman_collection.json",
                content = objectMapper.writeValueAsString(collection),
                language = "json"
            )
        )
    }

    private fun buildCollection(model: TestModel): PostmanCollection {
        val folders = groupEndpoints(model.endpoints)

        return PostmanCollection(
            info = PostmanInfo(
                name = model.meta.specTitle,
                description = "Generated by Pe4King\nSource: ${model.meta.source}"
            ),
            item = folders,
            variable = listOf(
                PostmanVariable("baseUrl", model.config.baseUrl),
                PostmanVariable("authToken", "")
            ),
            auth = PostmanAuth(
                type = "bearer",
                bearer = listOf(PostmanAuthItem("token", "{{authToken}}"))
            )
        )
    }

    private fun groupEndpoints(endpoints: List<EndpointTest>): List<PostmanFolder> {
        val groups = mutableMapOf<String, MutableList<PostmanItem>>()

        for (endpointTest in endpoints) {
            val endpoint = endpointTest.endpoint
            val folderName = endpoint.tags.firstOrNull() ?: extractPathPrefix(endpoint.path)

            if (folderName !in groups) {
                groups[folderName] = mutableListOf()
            }

            for (scenario in endpointTest.scenarios) {
                if (!scenario.disabled) {
                    groups[folderName]!!.add(buildItem(endpointTest, scenario))
                }
            }
        }

        return groups.map { (name, items) ->
            PostmanFolder(
                name = formatFolderName(name),
                item = items
            )
        }
    }

    private fun buildItem(endpointTest: EndpointTest, scenario: TestScenario): PostmanItem {
        val endpoint = endpointTest.endpoint
        var path = endpoint.path
        val variables = mutableListOf<PostmanUrlVariable>()

        // Convert path params
        for ((name, value) in scenario.request.pathParams) {
            path = path.replace("{$name}", ":$name")
            val varValue = if (value.startsWith("\${")) "{{$name}}" else value
            variables.add(PostmanUrlVariable(name, varValue))
        }

        val pathSegments = path.split("/").filter { it.isNotEmpty() }

        // Query params
        val queryParams = scenario.request.queryParams.map { (k, v) ->
            PostmanQueryParam(k, v)
        }.takeIf { it.isNotEmpty() }

        val request = PostmanRequest(
            method = endpoint.method.name,
            header = listOf(
                PostmanHeader("Content-Type", "application/json"),
                PostmanHeader("Accept", "application/json")
            ),
            url = PostmanUrl(
                raw = "{{baseUrl}}$path",
                host = listOf("{{baseUrl}}"),
                path = pathSegments,
                variable = variables.takeIf { it.isNotEmpty() },
                query = queryParams
            ),
            body = scenario.request.body?.let { body ->
                PostmanBody(
                    mode = "raw",
                    raw = when (body) {
                        is String -> body
                        else -> objectMapper.writeValueAsString(body)
                    },
                    options = PostmanBodyOptions(PostmanRawOptions("json"))
                )
            }
        )

        // Events (scripts)
        val events = mutableListOf<PostmanEvent>()

        // Pre-request script
        if (endpoint.pathParams.isNotEmpty() || scenario.request.body != null) {
            val preScript = scripts.generatePreRequestScript(
                hasPathParams = endpoint.pathParams.isNotEmpty(),
                hasBody = scenario.request.body != null
            )
            events.add(PostmanEvent(
                listen = "prerequest",
                script = PostmanScript(exec = preScript)
            ))
        }

        // Test script
        val testScript = scripts.generateTestScript(
            statusCode = scenario.expected.statusCode,
            assertions = scenario.expected.assertions,
            testName = scenario.displayName
        )
        events.add(PostmanEvent(
            listen = "test",
            script = PostmanScript(exec = testScript)
        ))

        return PostmanItem(
            name = scenario.displayName,
            request = request,
            event = events
        )
    }

    private fun extractPathPrefix(path: String): String {
        val segments = path.split("/").filter { it.isNotEmpty() && !it.startsWith("{") }
        return if (segments.size >= 2) {
            segments.take(2).joinToString("/")
        } else {
            segments.firstOrNull() ?: "default"
        }
    }

    private fun formatFolderName(name: String): String {
        return name.split(Regex("[/_-]"))
            .joinToString(" ") { it.replaceFirstChar { c -> c.uppercase() } }
    }
}
