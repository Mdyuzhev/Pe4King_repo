/**
 * Export collection to pytest tests
 */

import {
  ExportConfig,
  ExportTestCase,
  ExportAssertion,
  ExportFile,
  ExportResult
} from '../export-models';

/**
 * Generate pytest test file(s) from test cases
 */
export function exportToPytest(
  testCases: ExportTestCase[],
  config: ExportConfig
): ExportResult {
  const files: ExportFile[] = [];
  const errors: string[] = [];

  try {
    if (config.singleFile) {
      // All tests in one file
      const content = generatePytestFile(testCases, config);
      files.push({
        filename: `test_${config.moduleName || 'api'}.py`,
        content,
        language: 'python'
      });
    } else {
      // Group by tags (folders)
      const grouped = groupByTag(testCases);

      for (const [tag, cases] of Object.entries(grouped)) {
        const content = generatePytestFile(cases, config, tag);
        const filename = tag ? `test_${sanitize(tag)}.py` : `test_${config.moduleName || 'api'}.py`;
        files.push({ filename, content, language: 'python' });
      }
    }

    // Add conftest.py if needed
    if (config.includeSetup) {
      files.push({
        filename: 'conftest.py',
        content: generateConftest(config),
        language: 'python'
      });
    }

    return { success: true, files };
  } catch (error) {
    errors.push((error as Error).message);
    return { success: false, files, errors };
  }
}

/**
 * Generate single pytest file
 */
function generatePytestFile(
  testCases: ExportTestCase[],
  config: ExportConfig,
  moduleName?: string
): string {
  const indent = config.indent || '    ';
  const lines: string[] = [];

  // Imports
  lines.push('"""');
  lines.push(`API Tests${moduleName ? ` - ${moduleName}` : ''}`);
  lines.push('Generated by Pe4King');
  lines.push('"""');
  lines.push('');
  lines.push('import pytest');
  lines.push('import requests');
  lines.push('import re');
  lines.push('from jsonpath_ng import parse as jsonpath');
  lines.push('');
  lines.push('');

  // Base URL
  if (config.baseUrl) {
    lines.push(`BASE_URL = "${config.baseUrl}"`);
    lines.push('');
  }

  // Variable store
  if (config.includeVariables) {
    lines.push('# Variable store for chained requests');
    lines.push('_variables = {}');
    lines.push('');
    lines.push('');
    lines.push('def get_var(name: str) -> str:');
    lines.push(`${indent}"""Get variable value"""`);
    lines.push(`${indent}return _variables.get(name, f"{{{{{name}}}}}")`);
    lines.push('');
    lines.push('');
    lines.push('def set_var(name: str, value) -> None:');
    lines.push(`${indent}"""Set variable value"""`);
    lines.push(`${indent}_variables[name] = value`);
    lines.push('');
    lines.push('');
    lines.push('def resolve_vars(text: str) -> str:');
    lines.push(`${indent}"""Replace {{var}} with values"""`);
    lines.push(`${indent}def replacer(m):`);
    lines.push(`${indent}${indent}return str(get_var(m.group(1)))`);
    lines.push(`${indent}return re.sub(r'\\{\\{(\\w+)\\}\\}', replacer, text)`);
    lines.push('');
    lines.push('');
  }

  // Test class
  lines.push(`class Test${toPascalCase(moduleName || 'Api')}:`);
  lines.push(`${indent}"""${moduleName || 'API'} Tests"""`);
  lines.push('');

  // Generate each test
  for (const testCase of testCases) {
    lines.push(...generateTestMethod(testCase, config));
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generate single test method
 */
function generateTestMethod(
  testCase: ExportTestCase,
  config: ExportConfig
): string[] {
  const indent = config.indent || '    ';
  const lines: string[] = [];

  // Order decorator if needed
  if (testCase.order !== undefined) {
    lines.push(`${indent}@pytest.mark.order(${testCase.order})`);
  }

  // Test method
  lines.push(`${indent}def test_${testCase.name}(self, base_url):`);
  lines.push(`${indent}${indent}"""${testCase.description || testCase.name}"""`);

  // URL with variable resolution
  const url = config.includeVariables
    ? `resolve_vars(f"{base_url}${testCase.url}")`
    : `f"{base_url}${testCase.url}"`;
  lines.push(`${indent}${indent}url = ${url}`);

  // Headers
  if (Object.keys(testCase.headers).length > 0) {
    lines.push(`${indent}${indent}headers = {`);
    for (const [key, value] of Object.entries(testCase.headers)) {
      const val = config.includeVariables ? `resolve_vars("${value}")` : `"${value}"`;
      lines.push(`${indent}${indent}${indent}"${key}": ${val},`);
    }
    lines.push(`${indent}${indent}}`);
  } else {
    lines.push(`${indent}${indent}headers = {}`);
  }

  // Body
  if (testCase.body) {
    const bodyStr = JSON.stringify(testCase.body, null, 4)
      .split('\n')
      .map((line, i) => i === 0 ? line : indent + indent + line)
      .join('\n');
    lines.push(`${indent}${indent}body = ${bodyStr}`);
  }

  // Request
  const bodyArg = testCase.body ? ', json=body' : '';
  lines.push('');
  lines.push(`${indent}${indent}response = requests.${testCase.method.toLowerCase()}(`);
  lines.push(`${indent}${indent}${indent}url,`);
  lines.push(`${indent}${indent}${indent}headers=headers${bodyArg}`);
  lines.push(`${indent}${indent})`);
  lines.push('');

  // Assertions
  for (const assertion of testCase.assertions) {
    lines.push(...generateAssertion(assertion, config));
  }

  // Variable extractions
  if (config.includeVariables && testCase.extractVariables?.length) {
    lines.push('');
    lines.push(`${indent}${indent}# Extract variables`);
    lines.push(`${indent}${indent}data = response.json()`);

    for (const extraction of testCase.extractVariables) {
      lines.push(`${indent}${indent}set_var("${extraction.name}", jsonpath("${extraction.path}").find(data)[0].value)`);
    }
  }

  return lines;
}

/**
 * Generate assertion code
 */
function generateAssertion(
  assertion: ExportAssertion,
  config: ExportConfig
): string[] {
  const indent = config.indent || '    ';
  const i2 = indent + indent;
  const lines: string[] = [];

  switch (assertion.type) {
    case 'status':
      if (assertion.statusCode) {
        lines.push(`${i2}assert response.status_code == ${assertion.statusCode}`);
      } else if (assertion.statusFamily) {
        const first = assertion.statusFamily.charAt(0);
        lines.push(`${i2}assert response.status_code // 100 == ${first}`);
      }
      break;

    case 'body':
      if (assertion.path) {
        const pathExpr = `jsonpath("${assertion.path}").find(response.json())`;

        if (assertion.exists) {
          lines.push(`${i2}assert len(${pathExpr}) > 0, "Field ${assertion.path} not found"`);
        }
        if (assertion.notNull) {
          lines.push(`${i2}matches = ${pathExpr}`);
          lines.push(`${i2}assert len(matches) > 0 and matches[0].value is not None`);
        }
        if (assertion.equals !== undefined) {
          const expected = JSON.stringify(assertion.equals);
          lines.push(`${i2}assert ${pathExpr}[0].value == ${expected}`);
        }
        if (assertion.arrayLength !== undefined) {
          const op = assertion.arrayOp || '==';
          lines.push(`${i2}assert len(${pathExpr}) ${op} ${assertion.arrayLength}`);
        }
      }
      break;

    case 'header':
      if (assertion.headerName) {
        if (assertion.exists) {
          lines.push(`${i2}assert "${assertion.headerName}" in response.headers`);
        }
        if (assertion.headerValue) {
          lines.push(`${i2}assert response.headers.get("${assertion.headerName}") == "${assertion.headerValue}"`);
        }
        if (assertion.contains) {
          lines.push(`${i2}assert "${assertion.contains}" in response.headers.get("${assertion.headerName}", "")`);
        }
      }
      break;

    case 'time':
      if (assertion.maxMs) {
        lines.push(`${i2}assert response.elapsed.total_seconds() * 1000 < ${assertion.maxMs}`);
      }
      break;

    case 'custom':
      if (assertion.expression) {
        // Convert JS expression to Python
        const pyExpr = jsToPython(assertion.expression);
        lines.push(`${i2}# ${assertion.description || 'Custom assertion'}`);
        lines.push(`${i2}data = response.json()`);
        lines.push(`${i2}assert ${pyExpr}`);
      }
      break;
  }

  return lines;
}

/**
 * Generate conftest.py
 */
function generateConftest(config: ExportConfig): string {
  return `"""
Pytest configuration and fixtures
Generated by Pe4King
"""

import pytest


@pytest.fixture(scope="session")
def base_url():
    """Base URL for API tests"""
    return "${config.baseUrl || 'http://localhost:8080'}"


@pytest.fixture(autouse=True)
def reset_variables():
    """Reset variables before each test module"""
    try:
        from test_api import _variables
        _variables.clear()
    except ImportError:
        pass
    yield
`;
}

/**
 * Convert JS expression to Python (basic)
 */
function jsToPython(js: string): string {
  return js
    .replace(/===?/g, '==')
    .replace(/!==?/g, '!=')
    .replace(/&&/g, ' and ')
    .replace(/\|\|/g, ' or ')
    .replace(/!/g, 'not ')
    .replace(/true/g, 'True')
    .replace(/false/g, 'False')
    .replace(/null/g, 'None')
    .replace(/response\.body/g, 'data')
    .replace(/response\.status/g, 'response.status_code')
    .replace(/\.length/g, ')')
    .replace(/len\(/g, 'len(');
}

/**
 * Helper functions
 */
function groupByTag(testCases: ExportTestCase[]): Record<string, ExportTestCase[]> {
  const groups: Record<string, ExportTestCase[]> = { '': [] };

  for (const tc of testCases) {
    const tag = tc.tags?.[0] || '';
    if (!groups[tag]) groups[tag] = [];
    groups[tag].push(tc);
  }

  return groups;
}

function sanitize(name: string): string {
  return name.toLowerCase().replace(/[^a-z0-9]+/g, '_');
}

function toPascalCase(str: string): string {
  return str
    .split(/[^a-zA-Z0-9]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}
