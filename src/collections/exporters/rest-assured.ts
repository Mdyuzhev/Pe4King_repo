/**
 * Export collection to REST Assured tests (Java) - 3-layer architecture
 *
 * Layer 1: BaseTest.java, BaseClient.java
 * Layer 2: ApiClient.java
 * Layer 3: ApiTest.java
 */

import {
  ExportConfig,
  ExportTestCase,
  ExportAssertion,
  ExportFile,
  ExportResult
} from '../export-models';

// =============================================================================
// Templates
// =============================================================================

const BASE_TEST_TEMPLATE = `package {package}.base;

import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import io.restassured.specification.RequestSpecification;
import org.junit.jupiter.api.BeforeAll;

/**
 * Base test class with common setup
 * Generated by Pe4King
 */
public abstract class BaseTest {

    protected static RequestSpecification spec;
    protected static RequestSpecification specNoAuth;
    protected static String baseUrl;

    @BeforeAll
    static void baseSetup() {
        baseUrl = System.getenv().getOrDefault("API_BASE_URL", "{baseUrl}");
        String token = System.getenv().getOrDefault("API_TOKEN", "");

        specNoAuth = RestAssured.given()
            .baseUri(baseUrl)
            .contentType(ContentType.JSON)
            .accept(ContentType.JSON);

        spec = RestAssured.given()
            .baseUri(baseUrl)
            .contentType(ContentType.JSON)
            .accept(ContentType.JSON);

        if (!token.isEmpty()) {
            spec = spec.header("Authorization", "Bearer " + token);
        }

        RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();
    }
}
`;

const BASE_CLIENT_TEMPLATE = `package {package}.base;

import io.restassured.http.ContentType;
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;
import static io.restassured.RestAssured.given;

import java.util.Map;

/**
 * Base API client with common request methods
 * Generated by Pe4King
 */
public abstract class BaseClient {

    protected RequestSpecification spec;

    public BaseClient(RequestSpecification spec) {
        this.spec = spec;
    }

    protected Response doGet(String path) {
        return given().spec(spec).when().get(path);
    }

    protected Response doGet(String path, Map<String, ?> queryParams) {
        return given().spec(spec).queryParams(queryParams).when().get(path);
    }

    protected Response doPost(String path, Object body) {
        return given().spec(spec).contentType(ContentType.JSON).body(body).when().post(path);
    }

    protected Response doPut(String path, Object body) {
        return given().spec(spec).contentType(ContentType.JSON).body(body).when().put(path);
    }

    protected Response doPatch(String path, Object body) {
        return given().spec(spec).contentType(ContentType.JSON).body(body).when().patch(path);
    }

    protected Response doDelete(String path) {
        return given().spec(spec).when().delete(path);
    }

    protected String resolveVars(String template, Map<String, Object> variables) {
        String result = template;
        for (Map.Entry<String, Object> entry : variables.entrySet()) {
            result = result.replace("{{" + entry.getKey() + "}}", String.valueOf(entry.getValue()));
        }
        return result;
    }
}
`;

const API_CLIENT_HEADER = `package {package}.clients;

import {package}.base.BaseClient;
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;

import java.util.Map;
import java.util.HashMap;

/**
 * API Client for {collectionName}
 * Generated by Pe4King
 */
public class {className} extends BaseClient {

    private Map<String, Object> variables = new HashMap<>();

    public {className}(RequestSpecification spec) {
        super(spec);
    }

    public void setVariable(String name, Object value) {
        variables.put(name, value);
    }

    public Object getVariable(String name) {
        return variables.get(name);
    }

`;

const API_CLIENT_METHOD = `
    /**
     * {description}
     * {method} {path}
     */
    public Response {methodName}({parameters}) {
        String url = resolveVars("{path}", variables);
{bodySetup}
        return {requestChain};
    }
`;

const API_CLIENT_FOOTER = `}
`;

const TEST_CLASS_HEADER = `package {package}.tests;

import {package}.base.BaseTest;
import {package}.clients.{clientClass};
import io.restassured.response.Response;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

import java.util.Map;
import java.util.HashMap;

/**
 * API Tests for {collectionName}
 * Generated by Pe4King
 */
@TestMethodOrder(OrderAnnotation.class)
public class {className} extends BaseTest {

    private static {clientClass} client;

    @BeforeAll
    static void setupClient() {
        baseSetup();
        client = new {clientClass}(spec);
    }

`;

const TEST_METHOD = `
    @Test
    @Order({order})
    @DisplayName("{displayName}")
    void {testName}() {
        Response response = client.{clientMethod}({callParams});

        assertThat(response.statusCode(), {statusMatcher});
{assertions}
{extractions}
    }
`;

const TEST_CLASS_FOOTER = `}
`;

const POM_XML = `<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>{groupId}</groupId>
    <artifactId>api-tests</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <rest-assured.version>5.4.0</rest-assured.version>
        <junit.version>5.10.1</junit.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>io.rest-assured</groupId>
            <artifactId>rest-assured</artifactId>
            <version>\${rest-assured.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>\${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.hamcrest</groupId>
            <artifactId>hamcrest</artifactId>
            <version>2.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.2.2</version>
            </plugin>
        </plugins>
    </build>
</project>
`;

// =============================================================================
// Export Function
// =============================================================================

/**
 * Generate REST Assured test files from test cases (3-layer architecture)
 */
export function exportToRestAssured(
  testCases: ExportTestCase[],
  config: ExportConfig
): ExportResult {
  const files: ExportFile[] = [];
  const errors: string[] = [];

  try {
    const pkg = config.javaPackage || 'com.api.tests';
    const pkgPath = pkg.replace(/\./g, '/');
    const className = config.className || 'ApiTest';
    const clientClassName = className.replace(/Test$/, '') + 'Client';
    const collectionName = config.collectionName || 'API';

    // Layer 1: Base classes
    files.push({
      filename: `src/test/java/${pkgPath}/base/BaseTest.java`,
      content: BASE_TEST_TEMPLATE
        .replace(/{package}/g, pkg)
        .replace(/{baseUrl}/g, config.baseUrl || 'http://localhost:8080'),
      language: 'java'
    });

    files.push({
      filename: `src/test/java/${pkgPath}/base/BaseClient.java`,
      content: BASE_CLIENT_TEMPLATE.replace(/{package}/g, pkg),
      language: 'java'
    });

    // Layer 2: API Client
    files.push({
      filename: `src/test/java/${pkgPath}/clients/${clientClassName}.java`,
      content: generateApiClient(testCases, config, pkg, clientClassName, collectionName),
      language: 'java'
    });

    // Layer 3: Test class
    files.push({
      filename: `src/test/java/${pkgPath}/tests/${className}.java`,
      content: generateTestClass(testCases, config, pkg, className, clientClassName, collectionName),
      language: 'java'
    });

    // pom.xml
    const groupId = pkg.split('.').slice(0, 2).join('.') || 'com.api';
    files.push({
      filename: 'pom.xml',
      content: POM_XML.replace(/{groupId}/g, groupId),
      language: 'xml'
    });

    return { success: true, files };
  } catch (error) {
    errors.push((error as Error).message);
    return { success: false, files, errors };
  }
}

// =============================================================================
// Layer 2: API Client Generation
// =============================================================================

function generateApiClient(
  testCases: ExportTestCase[],
  config: ExportConfig,
  pkg: string,
  className: string,
  collectionName: string
): string {
  let content = API_CLIENT_HEADER
    .replace(/{package}/g, pkg)
    .replace(/{className}/g, className)
    .replace(/{collectionName}/g, collectionName);

  // Generate unique methods for each endpoint
  const generatedMethods = new Set<string>();

  for (const testCase of testCases) {
    const methodName = toMethodName(testCase.name);
    if (generatedMethods.has(methodName)) continue;
    generatedMethods.add(methodName);

    content += generateClientMethod(testCase, config);
  }

  content += API_CLIENT_FOOTER;
  return content;
}

function generateClientMethod(testCase: ExportTestCase, config: ExportConfig): string {
  const methodName = toMethodName(testCase.name);
  const method = testCase.method.toUpperCase();
  const hasBody = ['POST', 'PUT', 'PATCH'].includes(method);

  // Parameters
  const params: string[] = [];
  if (hasBody) {
    params.push('Object body');
  }

  // Build request chain
  let requestChain: string;
  let bodySetup = '';

  if (hasBody) {
    bodySetup = '        Object requestBody = body != null ? body : Map.of();\n';
    requestChain = `do${capitalize(method.toLowerCase())}(url, requestBody)`;
  } else if (method === 'DELETE') {
    requestChain = 'doDelete(url)';
  } else {
    requestChain = 'doGet(url)';
  }

  return API_CLIENT_METHOD
    .replace(/{description}/g, testCase.description || testCase.name)
    .replace(/{method}/g, method)
    .replace(/{path}/g, testCase.url)
    .replace(/{methodName}/g, methodName)
    .replace(/{parameters}/g, params.join(', '))
    .replace(/{bodySetup}/g, bodySetup)
    .replace(/{requestChain}/g, requestChain);
}

// =============================================================================
// Layer 3: Test Class Generation
// =============================================================================

function generateTestClass(
  testCases: ExportTestCase[],
  config: ExportConfig,
  pkg: string,
  className: string,
  clientClassName: string,
  collectionName: string
): string {
  let content = TEST_CLASS_HEADER
    .replace(/{package}/g, pkg)
    .replace(/{className}/g, className)
    .replace(/{clientClass}/g, clientClassName)
    .replace(/{collectionName}/g, collectionName);

  let order = 1;
  for (const testCase of testCases) {
    content += generateTestMethod(testCase, config, order++);
  }

  content += TEST_CLASS_FOOTER;
  return content;
}

function generateTestMethod(
  testCase: ExportTestCase,
  config: ExportConfig,
  order: number
): string {
  const clientMethod = toMethodName(testCase.name);
  const testName = 'test' + capitalize(clientMethod);
  const hasBody = ['POST', 'PUT', 'PATCH'].includes(testCase.method.toUpperCase());

  // Call params
  const callParams: string[] = [];
  if (hasBody) {
    if (testCase.body && Object.keys(testCase.body).length > 0) {
      callParams.push(objectToMapOf(testCase.body as Record<string, unknown>));
    } else {
      callParams.push('Map.of()');
    }
  }

  // Status matcher
  const statusMatcher = generateStatusMatcher(testCase.assertions);

  // Assertions
  const assertions = generateAssertions(testCase.assertions);

  // Variable extractions
  const extractions = generateExtractions(testCase, config);

  return TEST_METHOD
    .replace(/{order}/g, String(order))
    .replace(/{displayName}/g, escapeJava(testCase.description || testCase.name))
    .replace(/{testName}/g, testName)
    .replace(/{clientMethod}/g, clientMethod)
    .replace(/{callParams}/g, callParams.join(', '))
    .replace(/{statusMatcher}/g, statusMatcher)
    .replace(/{assertions}/g, assertions)
    .replace(/{extractions}/g, extractions);
}

function generateStatusMatcher(assertions: ExportAssertion[]): string {
  for (const assertion of assertions) {
    if (assertion.type === 'status') {
      if (assertion.statusCode) {
        return `equalTo(${assertion.statusCode})`;
      }
      if (assertion.statusFamily) {
        const family = assertion.statusFamily.charAt(0);
        return `allOf(greaterThanOrEqualTo(${family}00), lessThan(${parseInt(family) + 1}00))`;
      }
    }
  }
  return 'lessThan(400)'; // Default: success
}

function generateAssertions(assertions: ExportAssertion[]): string {
  const lines: string[] = [];

  for (const assertion of assertions) {
    if (assertion.type === 'status') continue; // Already handled

    const assertionLines = generateAssertion(assertion);
    for (const line of assertionLines) {
      lines.push(`        ${line}`);
    }
  }

  return lines.length > 0 ? '\n' + lines.join('\n') : '';
}

function generateAssertion(assertion: ExportAssertion): string[] {
  const lines: string[] = [];

  switch (assertion.type) {
    case 'body':
      if (assertion.path) {
        const jsonPath = assertion.path.startsWith('$')
          ? assertion.path.substring(2)
          : assertion.path;

        if (assertion.exists || assertion.notNull) {
          lines.push(`assertThat(response.jsonPath().get("${jsonPath}"), notNullValue());`);
        }
        if (assertion.equals !== undefined) {
          const expected = formatJavaValue(assertion.equals);
          lines.push(`assertThat(response.jsonPath().get("${jsonPath}"), equalTo(${expected}));`);
        }
        if (assertion.arrayLength !== undefined) {
          const matcher = getArrayMatcher(assertion.arrayOp || '==', assertion.arrayLength);
          lines.push(`assertThat(response.jsonPath().getList("${jsonPath}"), hasSize(${matcher}));`);
        }
      }
      break;

    case 'header':
      if (assertion.headerName) {
        if (assertion.exists) {
          lines.push(`assertThat(response.header("${assertion.headerName}"), notNullValue());`);
        }
        if (assertion.headerValue) {
          lines.push(`assertThat(response.header("${assertion.headerName}"), equalTo("${assertion.headerValue}"));`);
        }
      }
      break;

    case 'time':
      if (assertion.maxMs) {
        lines.push(`assertThat(response.time(), lessThan(${assertion.maxMs}L));`);
      }
      break;

    case 'custom':
      if (assertion.expression) {
        lines.push(`// Custom: ${assertion.description || assertion.expression}`);
        lines.push('// TODO: Convert to Java assertion');
      }
      break;
  }

  return lines;
}

function generateExtractions(testCase: ExportTestCase, config: ExportConfig): string {
  if (!config.includeVariables || !testCase.extractVariables?.length) {
    return '';
  }

  const lines: string[] = [''];
  lines.push('        // Extract variables');

  for (const extraction of testCase.extractVariables) {
    const jsonPath = extraction.path.startsWith('$')
      ? extraction.path.substring(2)
      : extraction.path;
    lines.push(`        client.setVariable("${extraction.name}", response.jsonPath().get("${jsonPath}"));`);
  }

  return lines.join('\n');
}

// =============================================================================
// Helpers
// =============================================================================

function toMethodName(name: string): string {
  return name
    .split(/[^a-zA-Z0-9]+/)
    .filter(Boolean)
    .map((word, i) => i === 0 ? word.toLowerCase() : capitalize(word))
    .join('');
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

function escapeJava(str: string): string {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t');
}

function formatJavaValue(value: unknown): string {
  if (value === null) return 'null';
  if (typeof value === 'string') return `"${escapeJava(value)}"`;
  if (typeof value === 'number') {
    return Number.isInteger(value) ? String(value) : `${value}f`;
  }
  if (typeof value === 'boolean') return String(value);
  return `"${escapeJava(JSON.stringify(value))}"`;
}

function objectToMapOf(obj: Record<string, unknown>): string {
  const entries = Object.entries(obj)
    .slice(0, 10)
    .map(([k, v]) => `"${k}", ${formatJavaValue(v)}`)
    .join(', ');
  return `Map.of(${entries})`;
}

function getArrayMatcher(op: string, value: number): string {
  switch (op) {
    case '>': return `greaterThan(${value})`;
    case '>=': return `greaterThanOrEqualTo(${value})`;
    case '<': return `lessThan(${value})`;
    case '<=': return `lessThanOrEqualTo(${value})`;
    case '!=': return `not(${value})`;
    default: return String(value);
  }
}
