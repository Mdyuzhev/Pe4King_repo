/**
 * Postman Collection v2.1 renderer with test scripts.
 */

import {
  TestModel,
  EndpointTest,
  TestScenario,
  GeneratedFile
} from '../../core/models';
import { BaseRenderer } from '../base-renderer';
import { PostmanScriptGenerator } from './test-scripts';

interface PostmanCollection {
  info: { name: string; description: string; schema: string };
  item: PostmanFolder[];
  variable: Array<{ key: string; value: string; type?: string }>;
  auth?: { type: string; bearer?: Array<{ key: string; value: string; type: string }> };
}

interface PostmanFolder {
  name: string;
  item: PostmanItem[];
}

interface PostmanItem {
  name: string;
  request: {
    method: string;
    header: Array<{ key: string; value: string }>;
    url: { raw: string; host: string[]; path: string[]; variable?: Array<{ key: string; value: string }> };
    body?: { mode: string; raw: string; options?: { raw: { language: string } } };
  };
  response: never[];
  event?: Array<{ listen: string; script: { type: string; exec: string[] } }>;
}

export class PostmanRenderer extends BaseRenderer {
  private scripts: PostmanScriptGenerator;

  constructor() {
    super();
    this.scripts = new PostmanScriptGenerator();
  }

  get name(): string { return 'postman'; }
  get fileExtension(): string { return '.json'; }

  render(model: TestModel): GeneratedFile[] {
    const collection = this.buildCollection(model);
    const filename = model.meta.specTitle.toLowerCase().replace(/[^a-z0-9]+/g, '_').substring(0, 50);

    return [{
      filename: `${filename}_postman_collection.json`,
      content: JSON.stringify(collection, null, 2),
      language: 'json'
    }];
  }

  private buildCollection(model: TestModel): PostmanCollection {
    const folders = this.groupEndpoints(model.endpoints);

    return {
      info: {
        name: model.meta.specTitle,
        description: `Generated by Pe4King\nSource: ${model.meta.source}`,
        schema: 'https://schema.getpostman.com/json/collection/v2.1.0/collection.json'
      },
      item: folders,
      variable: [
        { key: 'baseUrl', value: model.config.baseUrl, type: 'string' },
        { key: 'authToken', value: '', type: 'string' }
      ],
      auth: {
        type: 'bearer',
        bearer: [{ key: 'token', value: '{{authToken}}', type: 'string' }]
      }
    };
  }

  private groupEndpoints(endpoints: EndpointTest[]): PostmanFolder[] {
    const groups = new Map<string, PostmanItem[]>();

    for (const endpointTest of endpoints) {
      const { endpoint } = endpointTest;
      const folderName = endpoint.tags?.[0] || this.extractPathPrefix(endpoint.path);

      if (!groups.has(folderName)) groups.set(folderName, []);

      for (const scenario of endpointTest.scenarios) {
        if (!scenario.disabled) {
          groups.get(folderName)!.push(this.buildItem(endpointTest, scenario));
        }
      }
    }

    return Array.from(groups.entries()).map(([name, items]) => ({
      name: this.formatFolderName(name),
      item: items
    }));
  }

  private buildItem(endpointTest: EndpointTest, scenario: TestScenario): PostmanItem {
    const { endpoint } = endpointTest;

    let path = endpoint.path;
    const variables: Array<{ key: string; value: string }> = [];

    if (scenario.request.pathParams) {
      for (const [name, value] of Object.entries(scenario.request.pathParams)) {
        path = path.replace(`{${name}}`, `:${name}`);
        variables.push({ key: name, value: value.startsWith('${') ? `{{${name}}}` : value });
      }
    }

    const pathSegments = path.split('/').filter(p => p);

    const item: PostmanItem = {
      name: scenario.displayName,
      request: {
        method: endpoint.method,
        header: [
          { key: 'Content-Type', value: 'application/json' },
          { key: 'Accept', value: 'application/json' }
        ],
        url: {
          raw: `{{baseUrl}}${path}`,
          host: ['{{baseUrl}}'],
          path: pathSegments,
          ...(variables.length > 0 && { variable: variables })
        }
      },
      response: []
    };

    if (scenario.request.body) {
      item.request.body = {
        mode: 'raw',
        raw: JSON.stringify(scenario.request.body, null, 2),
        options: { raw: { language: 'json' } }
      };
    }

    // Test script
    const testScript = this.scripts.generateTestScript(
      scenario.expected.statusCode,
      scenario.expected.assertions,
      scenario.displayName
    );

    item.event = [{
      listen: 'test',
      script: { type: 'text/javascript', exec: testScript.split('\n') }
    }];

    // Pre-request script if needed
    if (endpoint.pathParams.length > 0 || scenario.request.body) {
      const preScript = this.scripts.generatePreRequestScript(
        endpoint.pathParams.length > 0,
        !!scenario.request.body
      );
      item.event.unshift({
        listen: 'prerequest',
        script: { type: 'text/javascript', exec: preScript.split('\n') }
      });
    }

    return item;
  }

  private extractPathPrefix(path: string): string {
    const segments = path.split('/').filter(p => p && !p.startsWith('{'));
    return segments.length >= 2 ? segments.slice(0, 2).join('/') : segments[0] || 'default';
  }

  private formatFolderName(name: string): string {
    return name.split(/[/_-]/).map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
  }
}
