/**
 * Templates for pytest test generation.
 * NOTE: Fixtures are ONLY in conftest.py, not duplicated here.
 */

export const PYTEST_FILE_HEADER = `"""
API Tests generated by Pe4King
Source: {source}
Generated: {generatedAt}
"""

import pytest
import requests
import re
from typing import Any, Dict


BASE_URL = "{baseUrl}"


# ============================================================================
# API Tests
# ============================================================================
`;

export const PYTEST_TEST_FUNCTION = `
def {testName}(api_client):
    """
    {displayName}
    Endpoint: {method} {path}
    """
    # Arrange
{arrange}

    # Act
    response = {request}

    # Assert
    assert response.status_code == {statusCode}
{assertions}
`;

export const PYTEST_NEGATIVE_TEST = `
@pytest.mark.skip(reason="{disabledReason}")
def {testName}(api_client):
    """
    {displayName}
    Expected: {statusCode}
    """
    # TODO: Implement negative test
    # - For 400: Send invalid/malformed request body
    # - For 401: Remove or invalidate auth token
    # - For 404: Use non-existent resource ID
    pass
`;

// ============================================================================
// Universal/Security Tests Templates
// ============================================================================

export const PYTEST_UNIVERSAL_FILE_HEADER = `"""
Security & Validation Tests generated by Pe4King
Source: {source}
Generated: {generatedAt}

These tests verify common security patterns and input validation
that should pass for any well-designed API.
"""

import pytest
import requests
from typing import Dict


BASE_URL = "{baseUrl}"


`;

export const PYTEST_AUTH_TEST = `
@pytest.mark.security
def test_{endpoint_name}_no_auth():
    """
    {description}
    Endpoint: {method} {path}
    """
    response = requests.{method_lower}(
        f"{BASE_URL}{path}",
        headers={"Content-Type": "application/json"}
    )
    assert response.status_code == 401, f"Expected 401, got {response.status_code}"
`;

export const PYTEST_INVALID_AUTH_TEST = `
@pytest.mark.security
def test_{endpoint_name}_invalid_auth():
    """
    {description}
    Endpoint: {method} {path}
    """
    response = requests.{method_lower}(
        f"{BASE_URL}{path}",
        headers={
            "Content-Type": "application/json",
            "Authorization": "{invalid_token}"
        }
    )
    assert response.status_code == 401, f"Expected 401, got {response.status_code}"
`;

export const PYTEST_VALIDATION_TEST = `
@pytest.mark.validation
def test_{endpoint_name}_{test_name}():
    """
    {description}
    Endpoint: {method} {path}
    """
    response = requests.{method_lower}(
        f"{BASE_URL}{path}",
        headers={"Content-Type": "application/json"},
        {request_args}
    )
    # May return 400 (validation error) or 404 (not found)
    assert response.status_code in [{expected_statuses}], f"Got {response.status_code}"
`;

export const PYTEST_INJECTION_TEST = `
@pytest.mark.security
def test_{endpoint_name}_{test_name}():
    """
    {description}
    Endpoint: {method} {path}
    Payload: {payload}
    """
    response = requests.{method_lower}(
        f"{BASE_URL}{path}",
        headers={"Content-Type": "application/json"},
        {request_args}
    )
    # Should NOT return 200 or 500 (injection should be blocked)
    assert response.status_code not in [200, 500], \\
        f"Potential injection vulnerability: got {response.status_code}"
`;

export const PYTEST_METHOD_NOT_ALLOWED_TEST = `
@pytest.mark.validation
def test_{endpoint_name}_method_not_allowed():
    """
    {description}
    Testing {wrong_method} on {method}-only endpoint
    """
    response = requests.{wrong_method_lower}(
        f"{BASE_URL}{path}",
        headers={"Content-Type": "application/json"}
    )
    assert response.status_code == 405, f"Expected 405, got {response.status_code}"
`;

export const PYTEST_SCOPE_TEST = `
@pytest.mark.security
def test_{endpoint_name}_{test_name}():
    """
    {description}
    Endpoint: {method} {path}
    Wrong scope: {wrong_scope}
    """
    response = requests.{method_lower}(
        f"{BASE_URL}{path}",
        headers={
            "Content-Type": "application/json",
            "Authorization": "Bearer token_with_wrong_scope"
        }
    )
    # Wrong OAuth2 scope should return 403 Forbidden
    assert response.status_code == 403, f"Expected 403, got {response.status_code}"
`;

export const PYTEST_PAGINATION_TEST = `
@pytest.mark.validation
def test_{endpoint_name}_{test_name}():
    """
    {description}
    Endpoint: {method} {path}
    """
    response = requests.{method_lower}(
        f"{BASE_URL}{path}",
        headers={"Content-Type": "application/json"},
        params={{query_params}}
    )
    # Invalid pagination should return 400
    assert response.status_code == 400, f"Expected 400, got {response.status_code}"
`;

export const PYTEST_CONTENT_TYPE_TEST = `
@pytest.mark.validation
def test_{endpoint_name}_{test_name}():
    """
    {description}
    Endpoint: {method} {path}
    Content-Type: {content_type}
    """
    response = requests.{method_lower}(
        f"{BASE_URL}{path}",
        headers={"Content-Type": "{content_type}"},
        data={body}
    )
    # Wrong content type should return 415 Unsupported Media Type
    assert response.status_code in [415, 400], f"Expected 415/400, got {response.status_code}"
`;

export const PYTEST_CONFTEST = `"""
Pytest configuration and fixtures.
"""

import pytest
import requests
import os
from typing import Any, Dict


def pytest_configure(config):
    """Configure pytest."""
    config.addinivalue_line("markers", "smoke: mark test as smoke test")
    config.addinivalue_line("markers", "regression: mark test as regression test")


@pytest.fixture(scope="session")
def base_url() -> str:
    """Base URL from environment or default."""
    return os.getenv("API_BASE_URL", "{baseUrl}")


@pytest.fixture(scope="session")
def auth_token() -> str:
    """Auth token from environment."""
    return os.getenv("API_TOKEN", "")


@pytest.fixture(scope="session")
def headers(auth_token: str) -> Dict[str, str]:
    """Common headers for all requests."""
    h = {
        "Content-Type": "application/json",
        "Accept": "application/json",
    }
    if auth_token:
        h["Authorization"] = f"Bearer {auth_token}"
    return h


@pytest.fixture
def api_client(base_url: str, headers: Dict[str, str]):
    """Simple API client fixture."""
    class ApiClient:
        def __init__(self):
            self.base_url = base_url
            self.headers = headers

        def get(self, path: str, **kwargs) -> requests.Response:
            return requests.get(f"{self.base_url}{path}", headers=self.headers, **kwargs)

        def post(self, path: str, json: Any = None, **kwargs) -> requests.Response:
            return requests.post(f"{self.base_url}{path}", headers=self.headers, json=json, **kwargs)

        def put(self, path: str, json: Any = None, **kwargs) -> requests.Response:
            return requests.put(f"{self.base_url}{path}", headers=self.headers, json=json, **kwargs)

        def patch(self, path: str, json: Any = None, **kwargs) -> requests.Response:
            return requests.patch(f"{self.base_url}{path}", headers=self.headers, json=json, **kwargs)

        def delete(self, path: str, **kwargs) -> requests.Response:
            return requests.delete(f"{self.base_url}{path}", headers=self.headers, **kwargs)

    return ApiClient()
`;
